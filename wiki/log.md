## Development log

### 2025.3

阅读 `wayland` 协议相关内容，了解底层原理与通信逻辑，学习 `xdg-shell` 核心协议的实现。

阅读 `smithay` 源码与最小实现。

### 2025.3.25

项目正式启动，基于 `smithay-smallvil` 进行基础 `compositor` 的开发，实现了 `client` 与 `compositor` 的简单通信。

### 2025.3.26

实现 `输入设备交互-鼠标与键盘` 与 `compositor` 的交互。

### 2025.3.29

添加 `cursor` 的渲染，实现桌面管理器内部的鼠标图标渲染，支持 `XCursor-default` 与 `wl_surface`。

### 2025.3.31

修复一些已知 `bug`，优化了代码结构，解耦 `winit` 与 `state` 的初始化函数代码。

手写简单的边框渲染 `shader`，配合 `keyboard-focus` 实现了渲染当前焦点所在窗口的边框提示。

### 2025.4.2

添加 `WorkspaceManager` 与 `OutputManager`，实现了简易的工作区切换逻辑。

### 2025.4.3

整理代码结构，优化函数逻辑

### 2025.4.7

实现简易的平铺逻辑，新增 `render` 管理所有渲染请求，优化代码结构。

### 2025.4.8

为 `cursor` 的 `grab` 行为新增 `grab` 指针图标。

### 2025.4.10

实现基于 `平衡二叉树` 平铺排序算法，暂时未实现删除的逻辑。

### 2025.4.12

尝试实现 `layer-shell` 协议。

### 2025.4.13

实现 `layer-shell` 协议，能够支持 `waybar` 的使用，修改了 `input` 模块的代码结构，更加清晰，减少代码重复。

### 2025.4.14

实现 `viewporter` 协议，能够支持 `swww` 的使用，提供更换背景图片的功能。

实现了 `default-layout` 的布局算法，在当前 `focus` 的窗口下插入新窗口。

暂时还未实现删除的算法逻辑。

### 2025.4.16

测试发现删除速度过慢。改用 `slotmap` 建立 `平衡二叉树`，实现查找，插入，删除为 `O(1)` 级别的布局算法。实现动态平铺插入与删除。暂时未支持窗口切换与移动。

### 2025.4.17-25

完成部分文本撰写工作

完成窗口倒置操作

修改了output改变时布局未改变的bug

### 2025.4.26

实现了窗口的动态 resize

修改了多 surface 软件导致焦点丢失的问题 - 绑定根 surface 到 focus

### 2025.4.27 - 5.5

实现tty裸机模式下的图形化界面启动，实现drm设备的最小启动

TODO: 完善drm设备管理，完成渲染额外元素

### 2025.5.6-10

重构代码结构，新增GlobalData作为最大数据集合

TODO: 完善渲染部分代码

### 2025.5.11-12

优化代码结构，寻找实现shader着色器渲染的方法

### 2025.5.13-14

优化tty渲染逻辑，由统一的时钟发起帧渲染事件

### 2025.5.15-17

模仿 niri render的宏定义，实现shader着色器的渲染

### 2025.5.18-20

修复致命 shader 渲染死循环bug，实现 tty 模式下的项目启动

### 2025.5.21-5.23

优化 workspace manager 对于 windows 的管理，优化布局设置过程的管理。
引入 tiled 与 floating 两种 windows 布局情况，为后期平铺式堆叠式多支持做基础。
TODO：完善 resize 部分的代码

### 2025.5.24

完善平铺模式下的grab机制

### 2025.5.25-28

完善平铺模式下的resize机制，修复了 wl_surface 与 wl_subsurface 导致的冲突，grab时需设置 wl_surface 为 focus。

### 2025.5.29-30

添加平铺模式与浮动模式的切换

### 2025.5.31-6.3

记录： 一开始想实现新的布局数据结构，摆脱二叉树的限制，这里记录一下思路和失败的原因。为每一个 window 分配一个 container 容器，container 容器记录其大小位置，并且维护一个 neighbors 表，用来记录上下左右的邻居信息。

失败原因：在 resize 的时候，通知邻居移动太过复杂，需要通知移动方向的邻居，还需要通知移动方向邻居的反方向的邻居，这里虽然成功实现了，但是移动的呈现效果不如人意。

此数据结构得到的移动性能不错，并且由于存储了服务端的 rec，在渲染或者其他操作时可以减少 wayland 通信需求，一定程度上有提升。

### 2025.6.4-6.5

实现 sprial 平铺布局，实现展开与恢复。这里二叉容器树的展开与恢复实现非常优雅，展开只需要实现修改window大小与位置，二叉树的树结构并没有修改，并且使用 split 存储 rec，使得恢复的时候只需要从 root 节点出发，重新刷新一下就可以了，非常优雅。

这里暂时删除了 float 部分的代码，禁用了 grab 和 resize，因为不是目前需要实现的重点。

下一步准备实现手动窗口移动与动画效果。

### 2025.6.6

成功实现动画效果，无需改变任何现有代码，实现如下：

树结构与计算得到的大小位置无需改变，将初始位置与终止位置记录，使用 Animation 包装，记录开始时间，每次渲染的时候进行判断，Animation如果还有内容，则使用当前时间获取到此时的大小与位置（使用不同的插值函数）。

### 2025.6.7

1. 修改了 VBlank 刷新不同步的问题 - 导致出现 tty 模式的撕裂现象，原因是 VBlank 应该是由 drm 主动发起，而不是由我们的 Compositor 控制。

2. 添加了 全局邻接表 数据结构，由于树结构的方向表达太贫瘠，因此实现邻接表，描述某个窗口和相邻的窗口的位置关系，并且基于此实现了键盘控制相邻窗口的交换。

这里对于 animation 的实现仍然有需要解决的问题。

由于窗口的几何信息需要通过cache读取，而cache存放的是当前动画运行的某一帧的内容，因此在动画过程中读取几何信息会导致错误，需要设置服务器位置或者更好的存储方案。

### 2025.6.8-6.10

1. 添加了一些 shader 代码，美化了边框显示，现在具有呼吸灯效果。

2. 完善了 layer-shell 协议的显示，现在 swww 已经可以正确显示壁纸了

3. 完善了 config 的内容，现在允许设置一些自启动项 - 输入法，壁纸等

4. 文本撰写

### 2025.6.11

1. 修复了 popups 和 layer-shell 窗口的相对位置的问题。传输的坐标为鼠标位置相对其 surface 在 output 下的起点。

2. 优化代码结构，整理顺序

### 2025.6.13

撰写初赛文档

### 2025.6.14-19

修复了 tty VBlank 同步问题，修复了 client 使用 dmabuf 导致的不同步撕裂问题。
client 使用 dmabuf 提交 buffer 的时候，不会保证 buffer 已经渲染完毕，需要在 compositor 中对其附加的同步 fence 进行验证，确保帧渲染完毕才进行 drm 交换。

### 2025.6.20-21

1. 添加了 rofi shell 脚本，用于快速启动所需程序

2. 添加 workspace 切换动画，优化了 workspace 的添加与删除

### 2025.6.22-23

完成全屏切换操作

### 2025.6.24-27

完善文本与ppt制作

### 2025.6.28

更新 smithay 版本为 0.7

### 2025.6.29-30

完善优化文本与ppt

### 2025.7.5-15

几个比较大的更新：

1. 更新了平铺树的算法，邻居节点图的引入还是太复杂了，考虑到简洁与高校，引入新的算法 - 容器式平铺二叉树：

    1. 这里为什么不适用多叉树：多叉树的引入对于插入，修改大小等都非常方便，而且整体更美观可读性更强，但是有一个致命的缺点：删除节点的时候，无法知晓让哪个相邻节点恢复，而二叉树的数据结构天然保证了每个节点一定会有唯一对应的 sibling (root节点除外)

    2. 做了什么修改：为了适配 resize，这里特别使用了 Vec<NodeId> 作为一个 Container 节点的 elements，不同于原先使用的 left 和 right，使用 vec 能够更好的进行不同方向的寻找。比如寻找左或者上，则将 idx-1 (当前节点在 vec 中的 position-1), 若存在，则直接修改对应节点，若不存在，向上将 parent 作为新的节点，执行 idx-1，一直遍历直到 root 节点。非常自然与高效

    3. resize 目前非常丝滑高效，核心是找到 direction 与移动方向一致的最大的，包含目标节点与修改方向对应节点的 parent，然后使用 update 更新整个子树。

2. 优化了服务端 cache 的存储。在 smithay 提供的框架中，不涉及平铺逻辑所以不会存储窗口的 rect，在只需要修改单个窗口的时候，不会有明显的损耗，而平铺逻辑下修改某一个窗口可能涉及到修改多个窗口的 rect，所以需要在服务端存储一份 rect cache 以确保高效。

3. 同时，由于我们引入了动画效果，其实质是每一帧通知 client 不同的大小，并且在不同位置，渲染 client 的内容，服务端存储 rect cache 后可以保证短时间内发生重合的动画效果，不会以当前帧窗口所处的位置与大小为执行点，而是以存储的最终态，保证了平铺结构的一致性。（在这里可能会有多次动画冲突，可以捕获当前窗口大小与位置作为起始点，执行新的动画效果 - 待开发）

4. 添加快捷键响应后续事件，如果响应了快捷键，返回 FilterResult::Intercept(()) 中断不向 client 发送键盘事件。

5. 对窗口删除做了一定优化，删除后执行一次鼠标的 focus 寻找，必定会自动绑定到 sibling 节点，对于 container 则是靠近鼠标的 node 节点。

### 2025.7.16

1. 添加 seat_primary_select 协议，为实现 copy 做准备

2. 添加了 XWayland 兼容层，x client 所有请求转角给 XWayland Compositor 处理，转化为 Wayland Compositor 可以读取的信息。

### 2025.7.17-18

新增 exchange 操作，交换相邻的两个窗口。如果两个窗口是 sibling，直接交换就可以了，如何识别不同 container 下的邻居是个难点，这里使用简化的操作，通过 find_neighbor 找到对应方向的，最有可能的节点，如果是 container，则遍历寻找 container 中最靠近（方向反向，比如找右边，那遍历往左）的 node 节点，这里有一个细节，方向与寻找方向一致，则直接往靠近方向，若与原先的一致，那么就是根据原先的位置来找，一般出现在两个 container 为 Vertical，我们认为上节点与上节点交换，所以使用 target 节点的 idx 信息即可。

### 2025.7.19-21

1. 优化了 xdg_shell 新建 toplevel 的流程，解决了“首帧闪烁”问题，根据是否是第一次提交和是否接收 compositor 发送的配置信息，来决定是否将窗口加入 mapped 组进行合成显示。

2. 优化了 xwayland 的建立行为，与 xdg_shell 思想一致。

3. 将 animation 从 render manager 中抽离出来作为一个单独的 manager，原先使用 loop handle 进行动画插入，因为 loop handle 不会马上优先执行，可能会导致动画开始的某几帧跳变。

4. 优化了 resize 操作，添加 resize max parent 缓存，不需要每次 resize 的时候都遍历一次树，删除了动画效果，更流畅。

5. 添加了 float 与 tiled 两种类型的布局窗口，对于某些不适合插入平铺状态的窗口，比如弹窗，子窗口这类，规划到 floating 窗口，并且基于父窗口分配大小与位置

6. TODO：完善 float 窗口的操作，完善 xwayland fullscreen 等监听，完成 screencopy 协议，调整 float 和 tiled 下以及 popups 等的 focus 遮挡关系与行为。