use smithay::{
    backend::input::{
        self, AbsolutePositionEvent, Axis, AxisSource, ButtonState, Event, InputBackend,
        PointerAxisEvent as _, PointerButtonEvent, PointerMotionEvent,
    },
    desktop::{layer_map_for_output, WindowSurface, WindowSurfaceType},
    input::pointer::{
        AxisFrame, ButtonEvent, GrabStartData as PointerGrabStartData, MotionEvent,
        RelativeMotionEvent,
    },
    utils::{Logical, Point, Serial, SERIAL_COUNTER},
    wayland::{
        pointer_constraints::{with_pointer_constraint, PointerConstraint},
        seat::WaylandFocus,
        shell::wlr_layer::Layer as WlrLayer,
    },
};

use crate::{input::focus::PointerFocusTarget, manager::window::WindowExt, protocol::xdg_shell::FullscreenSurface, state::GlobalData};

const BUTTON_LEFT: u32 = 272;
const BUTTON_RIGHT: u32 = 273;

impl GlobalData {
    pub fn on_pointer_motion<I: InputBackend>(&mut self, event: I::PointerMotionEvent) {
        let serial = SERIAL_COUNTER.next_serial();

        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let position = pointer.current_location();

        let under = self.focus_target_under(position, serial, true);

        let mut pointer_locked = false;
        let mut pointer_confined = false;
        let mut confine_region = None;
        if let Some((target, target_loc)) = &under {
            if let Some(wl_surface) = target.wl_surface().as_deref() {
                with_pointer_constraint(wl_surface, &pointer, |constraint| match constraint {
                    Some(constraint) => {
                        if !constraint
                            .region()
                            .map_or(true, |x| x.contains((position - *target_loc).to_i32_round()))
                        {
                            return;
                        }
                        match &*constraint {
                            PointerConstraint::Locked(_) => {
                                pointer_locked = true;
                            }
                            PointerConstraint::Confined(confine) => {
                                pointer_confined = true;
                                confine_region = confine.region().cloned();
                            }
                        }
                    }
                    None => {}
                });
            }
        }

        pointer.relative_motion(
            self,
            under.clone(),
            &RelativeMotionEvent {
                delta: event.delta(),
                delta_unaccel: event.delta_unaccel(),
                utime: event.time(),
            },
        );

        // If pointer is locked, only emit relative motion
        if pointer_locked {
            pointer.frame(self);
            return;
        } else {
            let new_position = position + event.delta();

            // clamp to screen limits
            // this event is never generated by winit
            let clamp_position = self.clamp_coords(new_position);
            let new_under = self.focus_target_under(clamp_position, serial, true);

            // If confined, don't move pointer if it would go outside surface or region
            if pointer_confined {
                if let Some((surface, surface_loc)) = &under {
                    if new_under.as_ref().and_then(|(under, _)| under.wl_surface())
                        != surface.wl_surface()
                    {
                        pointer.frame(self);
                        return;
                    }
                    if let Some(region) = confine_region {
                        if !region.contains((clamp_position - *surface_loc).to_i32_round()) {
                            pointer.frame(self);
                            return;
                        }
                    }
                }
            }

            pointer.motion(
                self,
                under,
                &MotionEvent {
                    location: clamp_position,
                    serial,
                    time: event.time_msec(),
                },
            );
            pointer.frame(self);

            // If pointer is now in a constraint region, activate it
            // TODO Anywhere else pointer is moved needs to do this
            if let Some((surface, surface_loc)) =
                new_under.and_then(|(target, loc)| Some((target.wl_surface()?.into_owned(), loc)))
            {
                with_pointer_constraint(&surface, &pointer, |constraint| match constraint {
                    Some(constraint) if !constraint.is_active() => {
                        let point = (clamp_position - surface_loc).to_i32_round();
                        if constraint
                            .region()
                            .map_or(true, |region| region.contains(point))
                        {
                            constraint.activate();
                        }
                    }
                    _ => {}
                });
            }
        }
    }

    pub fn on_pointer_motion_absolute<I: InputBackend>(
        &mut self,
        event: I::PointerMotionAbsoluteEvent,
    ) {
        let serial = SERIAL_COUNTER.next_serial();

        let output = self.output_manager.current_output();
        let output_geo = match self.output_manager.output_geometry(output) {
            Some(o) => o,
            None => {
                warn!("Failed to get output {:?} geometry", output);
                return;
            }
        };

        // because the absolute move, need to plus the output location
        let position = event.position_transformed(output_geo.size) + output_geo.loc.to_f64();

        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let under = self
            .focus_target_under(position, serial, true);

        pointer.motion(
            self,
            under,
            &MotionEvent {
                location: position,
                serial,
                time: event.time_msec(),
            },
        );
        pointer.frame(self);
    }

    pub fn on_pointer_button<I: InputBackend>(&mut self, event: I::PointerButtonEvent) {
        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let serial = SERIAL_COUNTER.next_serial();

        let button = event.button_code();
        let button_state = event.state();

        #[cfg(feature = "trace_input")]
        info!(
            "The PointerButton event, button: {button}, location: {:?}",
            pointer.current_location()
        );

        let pointer_loc = pointer.current_location();

        if let Some((target, target_loc)) = self.focus_target_under(pointer_loc, serial, true) {
            // start grab or resize
            if button_state == ButtonState::Pressed 
                && !pointer.is_grabbed() 
                && self.input_manager.is_mainmod_pressed() 
            {
               let start_data = PointerGrabStartData {
                    button,
                    focus: Some((target.clone().into(), target_loc)),
                    location: pointer.current_location(),
                };

                if button == BUTTON_LEFT {
                    // TODO: layer shell should not be grabed
                    // self.grab_move_request(target, &pointer, start_data, serial);
                } else if button == BUTTON_RIGHT {
                    // TODO: only windows could be resized
                    self.resize_move_request(&target, &pointer, start_data, serial);
                }

                return;
            }
        }

        pointer.button(
            self,
            &ButtonEvent {
                button,
                state: button_state,
                serial,
                time: event.time_msec(),
            },
        );

        pointer.frame(self);
    }

    pub fn on_pointer_axis<I: InputBackend>(&mut self, evt: I::PointerAxisEvent) {
        let horizontal_amount = evt.amount(input::Axis::Horizontal).unwrap_or_else(|| {
            evt.amount_v120(input::Axis::Horizontal).unwrap_or(0.0) * 15.0 / 120.
        });
        let vertical_amount = evt
            .amount(input::Axis::Vertical)
            .unwrap_or_else(|| evt.amount_v120(input::Axis::Vertical).unwrap_or(0.0) * 15.0 / 120.);
        let horizontal_amount_discrete = evt.amount_v120(input::Axis::Horizontal);
        let vertical_amount_discrete = evt.amount_v120(input::Axis::Vertical);

        {
            let mut frame = AxisFrame::new(evt.time_msec()).source(evt.source());
            if horizontal_amount != 0.0 {
                frame = frame
                    .relative_direction(Axis::Horizontal, evt.relative_direction(Axis::Horizontal));
                frame = frame.value(Axis::Horizontal, horizontal_amount);
                if let Some(discrete) = horizontal_amount_discrete {
                    frame = frame.v120(Axis::Horizontal, discrete as i32);
                }
            }
            if vertical_amount != 0.0 {
                frame = frame
                    .relative_direction(Axis::Vertical, evt.relative_direction(Axis::Vertical));
                frame = frame.value(Axis::Vertical, vertical_amount);
                if let Some(discrete) = vertical_amount_discrete {
                    frame = frame.v120(Axis::Vertical, discrete as i32);
                }
            }
            if evt.source() == AxisSource::Finger {
                if evt.amount(Axis::Horizontal) == Some(0.0) {
                    frame = frame.stop(Axis::Horizontal);
                }
                if evt.amount(Axis::Vertical) == Some(0.0) {
                    frame = frame.stop(Axis::Vertical);
                }
            }
            let pointer = self.input_manager.get_pointer();
            let pointer = match pointer {
                Some(k) => k,
                None => {
                    error!("get pointer error");
                    return;
                }
            };
            pointer.axis(self, frame);
            pointer.frame(self);
        }
    }

    pub fn focus_target_under(
        &mut self,
        pointer_loc: Point<f64, Logical>,
        serial: Serial,
        update_keyboard_focus: bool,
    ) -> Option<(PointerFocusTarget, Point<f64, Logical>)> {
        // TODO: remove clone
        let output = self.output_manager.current_output().clone();
        let output_geo = match self.output_manager.output_geometry(&output) {
            Some(g) => g,
            None => {
                warn!("Failed to get output {:?} geometry", output);
                return None;
            }
        };
        
        // The layer
        let layer_map = layer_map_for_output(&output);
        if let Some(layer) = layer_map
            .layer_under(WlrLayer::Overlay, pointer_loc - output_geo.loc.to_f64())
            .or_else(|| layer_map.layer_under(WlrLayer::Top, pointer_loc - output_geo.loc.to_f64()))
        {
            let layer_loc = layer_map.layer_geometry(layer).unwrap().loc.to_f64();

            if let Some((surface, surface_loc)) = layer.surface_under(
                pointer_loc - output_geo.loc.to_f64() - layer_loc,
                WindowSurfaceType::ALL,
            ) {
                if update_keyboard_focus && layer.can_receive_keyboard_focus() {
                    self.set_keyboard_focus(Some(layer.clone().into()), serial);
                }

                return Some((surface.into(), surface_loc.to_f64() + layer_loc + output_geo.loc.to_f64()));
            }
        }
        
        // fullscreen surface
        else if let Some((window, _)) = output
            .user_data()
            .get::<FullscreenSurface>()
            .and_then(|f| f.get())
        {
            if update_keyboard_focus {
                #[cfg(feature = "xwayland")]
                if let Some(surface) = window.x11_surface() {
                    self.state.xwm.as_mut().unwrap().raise_window(surface).unwrap();
                }

                self.set_keyboard_focus(Some(window.clone().into()), serial);
            }

            if let Some((surface, surface_loc)) = window
                .surface_under(pointer_loc - output_geo.loc.to_f64(), WindowSurfaceType::ALL)
            {
                match window.underlying_surface() {
                    WindowSurface::Wayland(_) => {
                        return Some((surface.into(), surface_loc.to_f64() + output_geo.loc.to_f64()));
                    }
                    #[cfg(feature = "xwayland")]
                    WindowSurface::X11(x11_surface) => {
                        return Some((x11_surface.clone().into(), surface_loc.to_f64() + output_geo.loc.to_f64()));
                    }
                }
            }
        }

        // The window
        else if let Some(window) =
            self.workspace_manager.window_under(pointer_loc)
        {
            let window_rect = window.get_rect().unwrap();
            let render_loc: Point<f64, Logical> = window_rect.loc.to_f64() - window.geometry().loc.to_f64();

            if update_keyboard_focus {
                #[cfg(feature = "xwayland")]
                if let Some(surface) = window.x11_surface() {
                    self.state.xwm.as_mut().unwrap().raise_window(surface).unwrap();
                }
                
                self.set_keyboard_focus(Some(window.clone().into()), serial);
            }

            if let Some((surface, surface_loc)) =
                window.surface_under(pointer_loc - render_loc - output_geo.loc.to_f64(), WindowSurfaceType::ALL)
            {
                match window.underlying_surface() {
                    WindowSurface::Wayland(_) => {
                        return Some((surface.into(), surface_loc.to_f64() + render_loc + output_geo.loc.to_f64()));
                    }
                    #[cfg(feature = "xwayland")]
                    WindowSurface::X11(x11_surface) => {
                        return Some((x11_surface.clone().into(), surface_loc.to_f64() + render_loc + output_geo.loc.to_f64()));
                    }
                }
            }
        }

        // The layer
        else if let Some(layer) = layer_map
            .layer_under(WlrLayer::Bottom, pointer_loc - output_geo.loc.to_f64())
            .or_else(|| {
                layer_map.layer_under(WlrLayer::Background, pointer_loc - output_geo.loc.to_f64())
            })
        {
            let layer_loc = layer_map.layer_geometry(layer).unwrap().loc.to_f64();

            if let Some((surface, surface_loc)) = layer.surface_under(
                pointer_loc - output_geo.loc.to_f64() - layer_loc,
                WindowSurfaceType::ALL,
            ) {
                if update_keyboard_focus && layer.can_receive_keyboard_focus() {
                    self.set_keyboard_focus(Some(layer.clone().into()), serial);
                }
                return Some((surface.into(), surface_loc.to_f64() + layer_loc + output_geo.loc.to_f64()));
            }
        }

        else if update_keyboard_focus {
            // unfocus
            self.set_keyboard_focus(None, serial);
        }

        None
    }

    fn clamp_coords(&self, pos: Point<f64, Logical>) -> Point<f64, Logical> {
        // TODO: finish this
        let output = self.output_manager.current_output();
        let output_geo = self.output_manager.output_geometry(output).unwrap();

        let x = pos.x.clamp(0.0, output_geo.size.w as f64);
        let y = pos.y.clamp(0.0, output_geo.size.h as f64);

        (x, y).into()
    }
}

