use smithay::{
    backend::input::{
        self, AbsolutePositionEvent, Axis, AxisSource, ButtonState, Event, InputBackend, PointerAxisEvent as _, PointerButtonEvent, PointerMotionEvent
    }, 
    desktop::{
        layer_map_for_output, WindowSurfaceType
    }, 
    input::pointer::{
            AxisFrame, ButtonEvent, GrabStartData as PointerGrabStartData, MotionEvent, RelativeMotionEvent
        }, 
    reexports::wayland_server::protocol::wl_surface::WlSurface, 
    utils::{
        Logical, Point, SERIAL_COUNTER
    }, 
    wayland::{
        compositor::get_parent, pointer_constraints::{
            with_pointer_constraint, PointerConstraint
        }, seat::WaylandFocus, shell::wlr_layer::Layer as WlrLayer
    }
};

use crate::state::GlobalData;

const BUTTON_LEFT: u32 = 272;
const BUTTON_RIGHT: u32 = 273;

impl GlobalData {
    pub fn on_pointer_motion<I: InputBackend>(&mut self, event: I::PointerMotionEvent) {

        let serial = SERIAL_COUNTER.next_serial();
                
        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let position = pointer.current_location();

        let under = self.surface_under(position);

        let mut pointer_locked = false;
        let mut pointer_confined = false;
        let mut confine_region = None;
        if let Some((surface, location)) = &under {
            with_pointer_constraint(surface, &pointer, |constraint| match constraint {
                Some(constraint) => {
                    if !constraint.region().map_or(true, |x| {
                        x.contains((position - *location).to_i32_round())
                    }) {
                        return;
                    }
                    match &*constraint {
                        PointerConstraint::Locked(_) => {
                            pointer_locked = true;
                        }
                        PointerConstraint::Confined(confine) => {
                            pointer_confined = true;
                            confine_region = confine.region().cloned();
                        }
                    }
                }
                None => {}
            });
        }

        pointer.relative_motion(
            self, 
            under.clone(), 
            &RelativeMotionEvent {
                delta: event.delta(),
                delta_unaccel: event.delta_unaccel(),
                utime: event.time(),
            },
        );

        // If pointer is locked, only emit relative motion
        if pointer_locked {
            pointer.frame(self);
            return;
        } else {
            let new_position = position + event.delta();
    
            // clamp to screen limits
            // this event is never generated by winit
            let clamp_position = self.clamp_coords(new_position);
            let new_under = self.surface_under(clamp_position);
    
            // set focus
            self.set_keyboard_focus(new_under.clone().map(|(surface, _)| surface), serial);

            // If confined, don't move pointer if it would go outside surface or region
            if pointer_confined {
                if let Some((surface, surface_loc)) = &under {
                    if new_under.as_ref().and_then(|(under, _)| under.wl_surface()) != surface.wl_surface() {
                        pointer.frame(self);
                        return;
                    }
                    if let Some(region) = confine_region {
                        if !region.contains((clamp_position - *surface_loc).to_i32_round()) {
                            pointer.frame(self);
                            return;
                        }
                    }
                }
            }
    
            pointer.motion(
                self,
                under,
                &MotionEvent {
                    location: clamp_position,
                    serial,
                    time: event.time_msec(),
                },
            );
            pointer.frame(self);
    
            // If pointer is now in a constraint region, activate it
            // TODO Anywhere else pointer is moved needs to do this
            if let Some((surface, surface_loc)) =
                new_under.and_then(|(target, loc)| Some((target.wl_surface()?.into_owned(), loc)))
            {
                with_pointer_constraint(&surface, &pointer, |constraint| match constraint {
                    Some(constraint) if !constraint.is_active() => {
                        let point = (clamp_position - surface_loc).to_i32_round();
                        if constraint.region().map_or(true, |region| region.contains(point)) {
                            constraint.activate();
                        }
                    }
                    _ => {}
                });
            }
        }
    }

    pub fn on_pointer_motion_absolute<I: InputBackend>(&mut self, event: I::PointerMotionAbsoluteEvent) {
        let serial = SERIAL_COUNTER.next_serial();

        let output = self.output_manager.current_output();
        let output_geo = match self.output_manager.output_geometry(output) {
            Some(o) => o,
            None => {
                warn!("Failed to get output {:?} geometry", output);
                return;
            }
        };

        // because the absolute move, need to plus the output location
        let position =
            event.position_transformed(output_geo.size) + output_geo.loc.to_f64();

        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let under = self.surface_under(position);

        // set focus
        self.set_keyboard_focus(under.clone().map(|(surface, _)| surface), serial);

        pointer.motion(
            self,
            under,
            &MotionEvent {
                location: position,
                serial,
                time: event.time_msec(),
            },
        );
        pointer.frame(self);
    }

    pub fn on_pointer_button<I: InputBackend>(&mut self, event: I::PointerButtonEvent) {
        let pointer = self.input_manager.get_pointer();
        let pointer = match pointer {
            Some(k) => k,
            None => {
                error!("get pointer error");
                return;
            }
        };

        let serial = SERIAL_COUNTER.next_serial();

        let button = event.button_code();
        let button_state = event.state();

        #[cfg(feature = "trace_input")]
        info!(
            "The PointerButton event, button: {button}, location: {:?}",
            pointer.current_location()
        );

        let position = pointer.current_location();
        let (wl_surface, loc) = match self.surface_under(position) {
            Some((wl_surface, loc)) => (wl_surface, loc),
            None => return
        };

        if button_state == ButtonState::Pressed && !pointer.is_grabbed() {
            self.set_keyboard_focus(Some(wl_surface.clone()), serial);
        }
        
        // grab and resize
        if self.input_manager.is_mainmod_pressed && button_state == ButtonState::Pressed {
            // if this is wl_subsurface
            let wl_surface = match get_parent(&wl_surface) {
                Some(wl_surface) => wl_surface,
                None => wl_surface,
            };

            let start_data = PointerGrabStartData {
                button,
                focus: Some((wl_surface.clone(), loc)),
                location: pointer.current_location(),
            };
            if button == BUTTON_LEFT {
                self.grab_move_request(&wl_surface, &pointer, start_data, serial);
            } else if button == BUTTON_RIGHT {
                self.resize_move_request(&wl_surface, &pointer, start_data, serial);
            }
            return;
        }

        pointer.button(
            self,
            &ButtonEvent {
                button,
                state: button_state,
                serial,
                time: event.time_msec(),
            },
        );

        pointer.frame(self);
        

    }

    pub fn on_pointer_axis<I: InputBackend>(&mut self, evt: I::PointerAxisEvent) {
        let horizontal_amount = evt
            .amount(input::Axis::Horizontal)
            .unwrap_or_else(|| evt.amount_v120(input::Axis::Horizontal).unwrap_or(0.0) * 15.0 / 120.);
        let vertical_amount = evt
            .amount(input::Axis::Vertical)
            .unwrap_or_else(|| evt.amount_v120(input::Axis::Vertical).unwrap_or(0.0) * 15.0 / 120.);
        let horizontal_amount_discrete = evt.amount_v120(input::Axis::Horizontal);
        let vertical_amount_discrete = evt.amount_v120(input::Axis::Vertical);
        
        {
            let mut frame = AxisFrame::new(evt.time_msec()).source(evt.source());
            if horizontal_amount != 0.0 {
                frame = frame.relative_direction(Axis::Horizontal, evt.relative_direction(Axis::Horizontal));
                frame = frame.value(Axis::Horizontal, horizontal_amount);
                if let Some(discrete) = horizontal_amount_discrete {
                    frame = frame.v120(Axis::Horizontal, discrete as i32);
                }
            }
            if vertical_amount != 0.0 {
                frame = frame.relative_direction(Axis::Vertical, evt.relative_direction(Axis::Vertical));
                frame = frame.value(Axis::Vertical, vertical_amount);
                if let Some(discrete) = vertical_amount_discrete {
                    frame = frame.v120(Axis::Vertical, discrete as i32);
                }
            }
            if evt.source() == AxisSource::Finger {
                if evt.amount(Axis::Horizontal) == Some(0.0) {
                    frame = frame.stop(Axis::Horizontal);
                }
                if evt.amount(Axis::Vertical) == Some(0.0) {
                    frame = frame.stop(Axis::Vertical);
                }
            }
            let pointer = self.input_manager.get_pointer();
            let pointer = match pointer {
                Some(k) => k,
                None => {
                    error!("get pointer error");
                    return;
                }
            };
            pointer.axis(self, frame);
            pointer.frame(self);
        }
    }

    fn surface_under(&mut self, position: Point<f64, Logical>) -> Option<(WlSurface, Point<f64, Logical>)> {
        // TODO: remove clone
        let output = self.output_manager.current_output().clone();
        let output_geo = match self.output_manager.output_geometry(&output) {
            Some(g) => g,
            None => {
                warn!("Failed to get output {:?} geometry", output);
                return None;
            }
        };

        let layer_map = layer_map_for_output(&output);

        // TODO: First is full screen
        // The layer
        if let Some(layer) = layer_map
            .layer_under(WlrLayer::Overlay, position - output_geo.loc.to_f64())
            .or_else(|| layer_map.layer_under(WlrLayer::Top, position - output_geo.loc.to_f64()))
        {
            if layer.can_receive_keyboard_focus() {
                if let Some((surface, loc)) = layer.surface_under(
                    position
                        - output_geo.loc.to_f64()
                        - layer_map.layer_geometry(layer).unwrap().loc.to_f64(),
                    WindowSurfaceType::ALL,
                ) {
                    return Some((surface, loc.to_f64()));
                }
            }
        } 
        
        // The window
        else if let Some((window, window_loc)) = self
            .workspace_manager
            .window_under(position)
            .map(|(w, p)| (w.clone(), p))
        {
            if let Some((surface, surface_loc)) = window
                .surface_under(position - window_loc.to_f64(), WindowSurfaceType::ALL)
                .map(|(surface, surface_loc)| (surface, surface_loc)) {

                    self.workspace_manager.set_focus(Some(window));
        
                    return Some((surface, (surface_loc + window_loc).to_f64()));
                }
        } 
        
        // The layer
        else if let Some(layer) = layer_map
            .layer_under(WlrLayer::Bottom, position - output_geo.loc.to_f64())
            .or_else(|| {
                layer_map.layer_under(WlrLayer::Background, position - output_geo.loc.to_f64())
            })
        {
            if layer.can_receive_keyboard_focus() {
                if let Some((surface, loc)) = layer.surface_under(
                    position
                        - output_geo.loc.to_f64()
                        - layer_map.layer_geometry(layer).unwrap().loc.to_f64(),
                    WindowSurfaceType::ALL,
                ) {
                    return Some((surface, loc.to_f64()));
                }
            }
        }
        None
    }

    fn clamp_coords(&self, pos: Point<f64, Logical>) -> Point<f64, Logical> {
        // TODO: finish this
        let output = self.output_manager.current_output();
        let output_geo = self.output_manager.output_geometry(output).unwrap();


        let x = pos.x.clamp(0.0, output_geo.size.w as f64);
        let y = pos.y.clamp(0.0, output_geo.size.h as f64);

        (x, y).into()
    }
}